"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2025 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class TagBinding(google.protobuf.message.Message):
    """A TagBinding represents a connection between a TagValue and a cloud
    resource Once a TagBinding is created, the TagValue is applied to all the
    descendants of the Google Cloud resource.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PARENT_FIELD_NUMBER: builtins.int
    TAG_VALUE_FIELD_NUMBER: builtins.int
    TAG_VALUE_NAMESPACED_NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Output only. The name of the TagBinding. This is a String of the form:
    `tagBindings/{full-resource-name}/{tag-value-name}` (e.g.
    `tagBindings/%2F%2Fcloudresourcemanager.googleapis.com%2Fprojects%2F123/tagValues/456`).
    """
    parent: builtins.str
    """The full resource name of the resource the TagValue is bound to.
    E.g. `//cloudresourcemanager.googleapis.com/projects/123`
    """
    tag_value: builtins.str
    """The TagValue of the TagBinding.
    Must be of the form `tagValues/456`.
    """
    tag_value_namespaced_name: builtins.str
    """The namespaced name for the TagValue of the TagBinding.
    Must be in the format
    `{parent_id}/{tag_key_short_name}/{short_name}`.

    For methods that support TagValue namespaced name, only one of
    tag_value_namespaced_name or tag_value may be filled. Requests with both
    fields will be rejected.
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        parent: builtins.str = ...,
        tag_value: builtins.str = ...,
        tag_value_namespaced_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["name", b"name", "parent", b"parent", "tag_value", b"tag_value", "tag_value_namespaced_name", b"tag_value_namespaced_name"]) -> None: ...

global___TagBinding = TagBinding

@typing.final
class CreateTagBindingMetadata(google.protobuf.message.Message):
    """Runtime operation information for creating a TagValue."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CreateTagBindingMetadata = CreateTagBindingMetadata

@typing.final
class CreateTagBindingRequest(google.protobuf.message.Message):
    """The request message to create a TagBinding."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_BINDING_FIELD_NUMBER: builtins.int
    VALIDATE_ONLY_FIELD_NUMBER: builtins.int
    validate_only: builtins.bool
    """Optional. Set to true to perform the validations necessary for creating the
    resource, but not actually perform the action.
    """
    @property
    def tag_binding(self) -> global___TagBinding:
        """Required. The TagBinding to be created."""

    def __init__(
        self,
        *,
        tag_binding: global___TagBinding | None = ...,
        validate_only: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["tag_binding", b"tag_binding"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["tag_binding", b"tag_binding", "validate_only", b"validate_only"]) -> None: ...

global___CreateTagBindingRequest = CreateTagBindingRequest

@typing.final
class DeleteTagBindingMetadata(google.protobuf.message.Message):
    """Runtime operation information for deleting a TagBinding."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___DeleteTagBindingMetadata = DeleteTagBindingMetadata

@typing.final
class DeleteTagBindingRequest(google.protobuf.message.Message):
    """The request message to delete a TagBinding."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Required. The name of the TagBinding. This is a String of the form:
    `tagBindings/{id}` (e.g.
    `tagBindings/%2F%2Fcloudresourcemanager.googleapis.com%2Fprojects%2F123/tagValues/456`).
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["name", b"name"]) -> None: ...

global___DeleteTagBindingRequest = DeleteTagBindingRequest

@typing.final
class ListTagBindingsRequest(google.protobuf.message.Message):
    """The request message to list all TagBindings for a parent."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    parent: builtins.str
    """Required. The full resource name of a resource for which you want to list
    existing TagBindings. E.g.
    "//cloudresourcemanager.googleapis.com/projects/123"
    """
    page_size: builtins.int
    """Optional. The maximum number of TagBindings to return in the response. The
    server allows a maximum of 300 TagBindings to return. If unspecified, the
    server will use 100 as the default.
    """
    page_token: builtins.str
    """Optional. A pagination token returned from a previous call to
    `ListTagBindings` that indicates where this listing should continue from.
    """
    def __init__(
        self,
        *,
        parent: builtins.str = ...,
        page_size: builtins.int = ...,
        page_token: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["page_size", b"page_size", "page_token", b"page_token", "parent", b"parent"]) -> None: ...

global___ListTagBindingsRequest = ListTagBindingsRequest

@typing.final
class ListTagBindingsResponse(google.protobuf.message.Message):
    """The ListTagBindings response."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_BINDINGS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    next_page_token: builtins.str
    """Pagination token.

    If the result set is too large to fit in a single response, this token
    is returned. It encodes the position of the current result cursor.
    Feeding this value into a new list request with the `page_token` parameter
    gives the next page of the results.

    When `next_page_token` is not filled in, there is no next page and
    the list returned is the last page in the result set.

    Pagination tokens have a limited lifetime.
    """
    @property
    def tag_bindings(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TagBinding]:
        """A possibly paginated list of TagBindings for the specified resource."""

    def __init__(
        self,
        *,
        tag_bindings: collections.abc.Iterable[global___TagBinding] | None = ...,
        next_page_token: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["next_page_token", b"next_page_token", "tag_bindings", b"tag_bindings"]) -> None: ...

global___ListTagBindingsResponse = ListTagBindingsResponse

@typing.final
class ListEffectiveTagsRequest(google.protobuf.message.Message):
    """The request message to ListEffectiveTags"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    parent: builtins.str
    """Required. The full resource name of a resource for which you want to list
    the effective tags. E.g.
    "//cloudresourcemanager.googleapis.com/projects/123"
    """
    page_size: builtins.int
    """Optional. The maximum number of effective tags to return in the response.
    The server allows a maximum of 300 effective tags to return in a single
    page. If unspecified, the server will use 100 as the default.
    """
    page_token: builtins.str
    """Optional. A pagination token returned from a previous call to
    `ListEffectiveTags` that indicates from where this listing should continue.
    """
    def __init__(
        self,
        *,
        parent: builtins.str = ...,
        page_size: builtins.int = ...,
        page_token: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["page_size", b"page_size", "page_token", b"page_token", "parent", b"parent"]) -> None: ...

global___ListEffectiveTagsRequest = ListEffectiveTagsRequest

@typing.final
class ListEffectiveTagsResponse(google.protobuf.message.Message):
    """The response of ListEffectiveTags."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EFFECTIVE_TAGS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    next_page_token: builtins.str
    """Pagination token.

    If the result set is too large to fit in a single response, this token
    is returned. It encodes the position of the current result cursor.
    Feeding this value into a new list request with the `page_token` parameter
    gives the next page of the results.

    When `next_page_token` is not filled in, there is no next page and
    the list returned is the last page in the result set.

    Pagination tokens have a limited lifetime.
    """
    @property
    def effective_tags(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveTag]:
        """A possibly paginated list of effective tags for the specified resource."""

    def __init__(
        self,
        *,
        effective_tags: collections.abc.Iterable[global___EffectiveTag] | None = ...,
        next_page_token: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["effective_tags", b"effective_tags", "next_page_token", b"next_page_token"]) -> None: ...

global___ListEffectiveTagsResponse = ListEffectiveTagsResponse

@typing.final
class EffectiveTag(google.protobuf.message.Message):
    """An EffectiveTag represents a tag that applies to a resource during policy
    evaluation. Tags can be either directly bound to a resource or inherited from
    its ancestor. EffectiveTag contains the name and
    namespaced_name of the tag value and tag key, with additional fields of
    `inherited` to indicate the inheritance status of the effective tag.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_VALUE_FIELD_NUMBER: builtins.int
    NAMESPACED_TAG_VALUE_FIELD_NUMBER: builtins.int
    TAG_KEY_FIELD_NUMBER: builtins.int
    NAMESPACED_TAG_KEY_FIELD_NUMBER: builtins.int
    TAG_KEY_PARENT_NAME_FIELD_NUMBER: builtins.int
    INHERITED_FIELD_NUMBER: builtins.int
    tag_value: builtins.str
    """Resource name for TagValue in the format `tagValues/456`."""
    namespaced_tag_value: builtins.str
    """The namespaced name of the TagValue. Can be in the form
    `{organization_id}/{tag_key_short_name}/{tag_value_short_name}` or
    `{project_id}/{tag_key_short_name}/{tag_value_short_name}` or
    `{project_number}/{tag_key_short_name}/{tag_value_short_name}`.
    """
    tag_key: builtins.str
    """The name of the TagKey, in the format `tagKeys/{id}`, such as
    `tagKeys/123`.
    """
    namespaced_tag_key: builtins.str
    """The namespaced name of the TagKey. Can be in the form
    `{organization_id}/{tag_key_short_name}` or
    `{project_id}/{tag_key_short_name}` or
    `{project_number}/{tag_key_short_name}`.
    """
    tag_key_parent_name: builtins.str
    """The parent name of the tag key.
    Must be in the format `organizations/{organization_id}` or
    `projects/{project_number}`
    """
    inherited: builtins.bool
    """Indicates the inheritance status of a tag value
    attached to the given resource. If the tag value is inherited from one of
    the resource's ancestors, inherited will be true. If false, then the tag
    value is directly attached to the resource, inherited will be false.
    """
    def __init__(
        self,
        *,
        tag_value: builtins.str = ...,
        namespaced_tag_value: builtins.str = ...,
        tag_key: builtins.str = ...,
        namespaced_tag_key: builtins.str = ...,
        tag_key_parent_name: builtins.str = ...,
        inherited: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["inherited", b"inherited", "namespaced_tag_key", b"namespaced_tag_key", "namespaced_tag_value", b"namespaced_tag_value", "tag_key", b"tag_key", "tag_key_parent_name", b"tag_key_parent_name", "tag_value", b"tag_value"]) -> None: ...

global___EffectiveTag = EffectiveTag
